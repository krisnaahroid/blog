{"ast":null,"code":"import { useState, useEffect } from 'react';\nexport default function useOnScreen(ref, rootMargin = '0px') {\n  // State and setter for storing whether element is visible\n  const {\n    0: isIntersecting,\n    1: setIntersecting\n  } = useState(false);\n  useEffect(() => {\n    const observer = new IntersectionObserver(([entry]) => {\n      // Update our state when observer callback fires\n      setIntersecting(entry.isIntersecting);\n    }, {\n      rootMargin\n    });\n\n    if (ref.current) {\n      observer.observe(ref.current);\n    }\n\n    return () => {\n      observer.unobserve(ref.current);\n    };\n  }, []); // Empty array ensures that effect is only run on mount and unmount\n\n  return isIntersecting;\n}","map":{"version":3,"sources":["/Users/ahroidlife/Documents/nextjs/blog/components/particles/useOnScreen.js"],"names":["useState","useEffect","useOnScreen","ref","rootMargin","isIntersecting","setIntersecting","observer","IntersectionObserver","entry","current","observe","unobserve"],"mappings":"AAAA,SAASA,QAAT,EAAmBC,SAAnB,QAAoC,OAApC;AAEA,eAAe,SAASC,WAAT,CAAqBC,GAArB,EAA0BC,UAAU,GAAG,KAAvC,EAA8C;AAC3D;AACA,QAAM;AAAA,OAACC,cAAD;AAAA,OAAiBC;AAAjB,MAAoCN,QAAQ,CAAC,KAAD,CAAlD;AAEAC,EAAAA,SAAS,CAAC,MAAM;AACd,UAAMM,QAAQ,GAAG,IAAIC,oBAAJ,CACf,CAAC,CAACC,KAAD,CAAD,KAAa;AACX;AACAH,MAAAA,eAAe,CAACG,KAAK,CAACJ,cAAP,CAAf;AACD,KAJc,EAKf;AACED,MAAAA;AADF,KALe,CAAjB;;AASA,QAAID,GAAG,CAACO,OAAR,EAAiB;AACfH,MAAAA,QAAQ,CAACI,OAAT,CAAiBR,GAAG,CAACO,OAArB;AACD;;AACD,WAAO,MAAM;AACXH,MAAAA,QAAQ,CAACK,SAAT,CAAmBT,GAAG,CAACO,OAAvB;AACD,KAFD;AAGD,GAhBQ,EAgBN,EAhBM,CAAT,CAJ2D,CAoBnD;;AAER,SAAOL,cAAP;AACD","sourcesContent":["import { useState, useEffect } from 'react';\n\nexport default function useOnScreen(ref, rootMargin = '0px') {\n  // State and setter for storing whether element is visible\n  const [isIntersecting, setIntersecting] = useState(false);\n\n  useEffect(() => {\n    const observer = new IntersectionObserver(\n      ([entry]) => {\n        // Update our state when observer callback fires\n        setIntersecting(entry.isIntersecting);\n      },\n      {\n        rootMargin\n      }\n    );\n    if (ref.current) {\n      observer.observe(ref.current);\n    }\n    return () => {\n      observer.unobserve(ref.current);\n    };\n  }, []); // Empty array ensures that effect is only run on mount and unmount\n\n  return isIntersecting;\n}"]},"metadata":{},"sourceType":"module"}