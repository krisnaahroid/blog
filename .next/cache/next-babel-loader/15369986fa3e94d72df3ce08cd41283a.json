{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport { useState, useEffect } from 'react';\nexport default function useOnScreen(ref) {\n  var rootMargin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '0px';\n\n  // State and setter for storing whether element is visible\n  var _useState = useState(false),\n      isIntersecting = _useState[0],\n      setIntersecting = _useState[1];\n\n  useEffect(function () {\n    var observer = new IntersectionObserver(function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 1),\n          entry = _ref2[0];\n\n      // Update our state when observer callback fires\n      setIntersecting(entry.isIntersecting);\n    }, {\n      rootMargin: rootMargin\n    });\n\n    if (ref.current) {\n      observer.observe(ref.current);\n    }\n\n    return function () {\n      observer.unobserve(ref.current);\n    };\n  }, []); // Empty array ensures that effect is only run on mount and unmount\n\n  return isIntersecting;\n}","map":{"version":3,"sources":["/Users/ahroidlife/Documents/nextjs/blog/components/particles/useOnScreen.js"],"names":["useState","useEffect","useOnScreen","ref","rootMargin","isIntersecting","setIntersecting","observer","IntersectionObserver","entry","current","observe","unobserve"],"mappings":";AAAA,SAASA,QAAT,EAAmBC,SAAnB,QAAoC,OAApC;AAEA,eAAe,SAASC,WAAT,CAAqBC,GAArB,EAA8C;AAAA,MAApBC,UAAoB,uEAAP,KAAO;;AAC3D;AAD2D,kBAEjBJ,QAAQ,CAAC,KAAD,CAFS;AAAA,MAEpDK,cAFoD;AAAA,MAEpCC,eAFoC;;AAI3DL,EAAAA,SAAS,CAAC,YAAM;AACd,QAAMM,QAAQ,GAAG,IAAIC,oBAAJ,CACf,gBAAa;AAAA;AAAA,UAAXC,KAAW;;AACX;AACAH,MAAAA,eAAe,CAACG,KAAK,CAACJ,cAAP,CAAf;AACD,KAJc,EAKf;AACED,MAAAA,UAAU,EAAVA;AADF,KALe,CAAjB;;AASA,QAAID,GAAG,CAACO,OAAR,EAAiB;AACfH,MAAAA,QAAQ,CAACI,OAAT,CAAiBR,GAAG,CAACO,OAArB;AACD;;AACD,WAAO,YAAM;AACXH,MAAAA,QAAQ,CAACK,SAAT,CAAmBT,GAAG,CAACO,OAAvB;AACD,KAFD;AAGD,GAhBQ,EAgBN,EAhBM,CAAT,CAJ2D,CAoBnD;;AAER,SAAOL,cAAP;AACD","sourcesContent":["import { useState, useEffect } from 'react';\n\nexport default function useOnScreen(ref, rootMargin = '0px') {\n  // State and setter for storing whether element is visible\n  const [isIntersecting, setIntersecting] = useState(false);\n\n  useEffect(() => {\n    const observer = new IntersectionObserver(\n      ([entry]) => {\n        // Update our state when observer callback fires\n        setIntersecting(entry.isIntersecting);\n      },\n      {\n        rootMargin\n      }\n    );\n    if (ref.current) {\n      observer.observe(ref.current);\n    }\n    return () => {\n      observer.unobserve(ref.current);\n    };\n  }, []); // Empty array ensures that effect is only run on mount and unmount\n\n  return isIntersecting;\n}"]},"metadata":{},"sourceType":"module"}